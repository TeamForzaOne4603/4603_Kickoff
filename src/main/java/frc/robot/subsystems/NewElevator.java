/*  Copyright (c) FIRST and other WPILib contributors.// Open Source Software; you can modify and/or share it under the terms of// the WPILib BSD license file in the root directory of this project.*/package frc.robot.subsystems;import com.revrobotics.spark.SparkBase.PersistMode;import com.revrobotics.spark.SparkMax;import com.revrobotics.spark.config.SparkBaseConfig.IdleMode;import com.revrobotics.spark.config.SparkMaxConfig;import com.revrobotics.spark.SparkLowLevel.MotorType;import edu.wpi.first.math.controller.ElevatorFeedforward;import edu.wpi.first.math.controller.ProfiledPIDController;import edu.wpi.first.math.trajectory.TrapezoidProfile;import edu.wpi.first.wpilibj.Encoder;import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;import edu.wpi.first.wpilibj2.command.Command;import edu.wpi.first.wpilibj2.command.SubsystemBase;import frc.robot.Constants.ElevatorConstants;import frc.robot.Constants.NewElevatorConstants;public class NewElevator extends SubsystemBase {  /** Creates a new NewElevator. */private static NewElevator mInstance;public static NewElevator getInstance() {if (mInstance == null) {mInstance = new NewElevator();}return mInstance;}private SparkMax m_leftMotor = new SparkMax(NewElevatorConstants.k_leftMotor, MotorType.kBrushless);private SparkMax m_rightMotor = new SparkMax(NewElevatorConstants.k_rightMotor, MotorType.kBrushless);private Encoder m_encoder = new Encoder(0, 1);private final TrapezoidProfile.Constraints m_constraints =new TrapezoidProfile.Constraints(NewElevatorConstants.k_maxVelocity, NewElevatorConstants.k_maxAcceleration);private final ProfiledPIDController m_controller =new ProfiledPIDController(NewElevatorConstants.k_P, NewElevatorConstants.k_I, NewElevatorConstants.k_D, m_constraints, 0.02);private final ElevatorFeedforward m_feedforward = new ElevatorFeedforward(NewElevatorConstants.k_S, NewElevatorConstants.k_G, NewElevatorConstants.k_V);private boolean isInPositionControl = false;private double setPoint = 0;public NewElevator() {m_encoder.setDistancePerPulse(1/285.666);m_encoder.setReverseDirection(false);  SparkMaxConfig elevatorConfig = new SparkMaxConfig();elevatorConfig.smartCurrentLimit(ElevatorConstants.k_supplyLimit);elevatorConfig.idleMode(IdleMode.kBrake);elevatorConfig.limitSwitch.reverseLimitSwitchEnabled(false);m_leftMotor.configure(elevatorConfig, com.revrobotics.spark.SparkBase.ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);m_rightMotor.configure(elevatorConfig.follow(m_leftMotor, true), com.revrobotics.spark.SparkBase.ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);}@Override public void periodic() {if (isInPositionControl) {m_leftMotor.setVoltage(m_controller.calculate(m_encoder.getDistance(), setPoint) + m_feedforward.calculate(m_controller.getSetpoint().velocity));}SmartDashboard.putNumber("Elevator", m_encoder.getDistance());}public Command manualMove(double speed){runOnce(()->{  isInPositionControl = false;});return runEnd(()->{m_leftMotor.set(0.3);}, ()-> {m_leftMotor.set(0);});}public Command goToPosition (double position){return runOnce(()->{setPosition(position);});}public void setPosition(double position){isInPositionControl = true;setPoint = position;}}